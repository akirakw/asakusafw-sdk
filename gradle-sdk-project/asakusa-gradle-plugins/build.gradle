/*
 * Copyright 2011-2016 Asakusa Framework Team.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
ext.parentPom = { f ->
    if (!f.exists()) {
        return null
    }
    def xml = new XmlSlurper().parse(f)
    return [
        projectVersion : xml.version.text(),
        coreVersion : xml['properties']['asakusafw.version'].text().replaceFirst('-hadoop[12]', ''),
    ]
}(project.file('../../pom.xml'))

defaultTasks 'clean', 'build', 'install', 'assembleTemplates'

apply plugin: 'groovy'
apply plugin: 'maven'
apply plugin: 'idea'
apply plugin: 'eclipse'

version = parentPom.projectVersion
group = 'com.asakusafw'

configurations {
    deployerJars
}

repositories {
    mavenCentral()
}

dependencies {
    compile gradleApi()
    deployerJars 'org.springframework.build:aws-maven:5.0.0.RELEASE'
}

project.sourceCompatibility = JavaVersion.toVersion('1.7')
project.targetCompatibility = JavaVersion.toVersion('1.7')

tasks.withType(AbstractCompile) { task ->
    task.options.encoding = 'UTF-8'
    if (System.getProperty('compiler.bootclasspath') != null) {
        task.options.compilerArgs += ['-bootclasspath', System.getProperty('compiler.bootclasspath')]
    }
}

eclipse.classpath {
    file {
        whenMerged { classpath ->
            classpath.entries.findAll {
                it.path.contains('org.eclipse.jdt.launching.JRE_CONTAINER')
            }.each {
                it.path = "org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-${sourceCompatibility}"
            }
            classpath.entries.unique()
        }
    }
}

groovydoc {
    docTitle "Asakusa Gradle Plugins ${version}"
    windowTitle "Asakusa Gradle Plugins ${version}"
    footer "Copyright 2011-${new Date().format('yyyy')} Asakusa Framework Team."
}

processResources { t ->
    File outputFile = new File(t.destinationDir, 'META-INF/asakusa-gradle/artifact.properties')
    t.inputs.properties parentPom
    t.outputs.file new File(t.destinationDir, 'META-INF/asakusa-gradle/artifact.properties')
    doLast {
        logger.info "injecting project version info: ${project.version}"
        if (!outputFile.parentFile.exists()) {
            mkdir outputFile.parentFile
        }

        Properties p = new Properties()
        p.put("plugin-version", parentPom.projectVersion)
        p.put("framework-version", parentPom.coreVersion)
        outputFile.withOutputStream { s ->
            p.store(s, null)
        }
    }
}

if (GradleVersion.current() >= GradleVersion.version('2.0')) {
    logger.lifecycle "introducing backport-compat23 (${GradleVersion.current()})"
    configurations {
        backports
    }
    dependencies {
        backports "org.codehaus.groovy:groovy-backports-compat23:${GroovySystem.version}"
    }
    jar {
        from({ configurations.backports.collect { zipTree(it) } }) {
            exclude '**/META-INF/MANIFEST.MF'
        }
    }
}

task sourcesJar(type: Jar) {
    classifier 'sources'
    from sourceSets.main.allSource
}

artifacts {
    archives tasks.sourcesJar
}

gradle.taskGraph.whenReady {taskGraph ->
    if (taskGraph.hasTask(uploadArchives)) {
        uploadArchives {
            repositories {
                mavenDeployer {
                    configuration = configurations.deployerJars

                    def releaseDef = getMavenServerDef('com.asakusafw.releases')
                    repository(id: 'com.asakusafw.releases', url: 's3://asakusafw/maven/releases') {
                        authentication(userName: releaseDef.username, passphrase: releaseDef.passphrase)
                    }

                    def snapshotDef = getMavenServerDef('com.asakusafw.snapshots')
                    snapshotRepository(id: 'com.asakusafw.snapshots', url: 's3://asakusafw/maven/snapshots') {
                        authentication(userName: snapshotDef.username, passphrase: snapshotDef.passphrase)
                    }
                }
            }
        }
    }
}

def getMavenServerDef(String id) {
    def settingsXml = new XmlSlurper().parse(
        new File(System.getProperty("user.home"), ".m2/settings.xml"))
    return settingsXml.servers.server.find {it.id.text() == id}
}

def templateProjectName = 'asakusa-project-template'
def outDir = "${buildDir}/templates"
def outTemplateProjectDir = "${outDir}/${templateProjectName}"

task generateTemplates << {
    delete outDir
    copy {
        from ("src/templates") {
            include '**/build.gradle'
            expand ([
                repSparkGradlePluginVersion: sparkGradlePluginVersion,
                repMavenRepoType: version.endsWith("SNAPSHOT") ? 'snapshots' : 'releases'
            ])
        }
        from ("src/templates") {
            exclude '**/build.gradle'
        }
        into outDir
    }

    mkdir "${outTemplateProjectDir}/src/main/java"
    mkdir "${outTemplateProjectDir}/src/main/resources"
    mkdir "${outTemplateProjectDir}/src/main/dmdl"
    mkdir "${outTemplateProjectDir}/src/main/libs"
    mkdir "${outTemplateProjectDir}/src/test/java"
}

task assembleTemplateProject (dependsOn: 'generateTemplates', type: Tar) {
    from (outDir) {
        include "${templateProjectName}/"
    }
    destinationDir buildDir
    compression Compression.GZIP
    archiveName "${templateProjectName}-${version}.tar.gz"
}

task assembleTemplates {
    dependsOn assembleTemplateProject
}
